# Object Oriented Programming
* This sheet functions as both a useful note and an assignment for ICS4U.
* As a requirement of the assignment, when adding examples, use C#.
* For information about non-OOP related concepts referred to here, see `C#.md`.

# Concepts
## General Concepts
* Encapsulation — Hiding properties behind getter and setter methods to prevent undesirable behaviour.

## Classes & Objects
* Class — A definition of an object. A class defines the variables and functions an object should have, but does not exist in memory.
* Object — An instance of a class. An object stores data in memory according to the definition of the class used to create it.

### Fields & Methods
* Member — A generic term for a class' fields and methods
* Field — A variable inside of a class.
    * Other terms are used to describe the same concept in other languages, such as "attributes" in C++ or "class/instance variables" (depending on whether they are `static` or not) in Java.
* Method — A function inside of a class.

### Properties
* Properties are a special type of class member in C# that behave as a regular data member while calling programmer-defined functions when read or assigned.
* Properties are used to wrap a private field with accessor (get & set) functions to control its accessibility.
    * Properties can also be "auto-implemented". Auto-implemented properties hold their own data and have autogenerated accessor functions.
* Properties are more intuitive to use and less verbose than a private field with accessor functions.
* For example, instead of:
    ```cs
    public class TimePeriod {
        private double _seconds;

        public double getHours() {
            return _seconds / 3600;
        }

        public void setHours(double hours) {
            _seconds = value * 3600;
        }
    }

    // Usage:
    var timePeriod = new TimePeriod();
    timePeriod.setHours(10);
    Console.WriteLine($"Time in hours: {timePeriod.getHours()}");
    ```
* You could use a property:
    ```cs
    public class TimePeriod {
        private double _seconds;

        public double Hours {
            get { return _seconds / 3600; }
            set { _seconds = value * 3600; }
        }
    }

    // Usage:
    var timePeriod = new TimePeriod();
    timePeriod.Hours = 10;
    Console.WriteLine($"Time in hours: {timePeriod.Hours}");

    // example from: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties (with modifications)
    ```
* The syntax for a property is:
    ```cs
    access_modifier type Name {
        get { get_body }
        set { set_body }
    }
    ```
* Alternatively, you can use an "expression body definition":
    ```cs
    // read only
    access_modifier type Name => get_expression;
    // read + write or write only
    access_modifier type Name {
        get => get_expression;
        set => set_expression;
    }
    ```
* Auto-implemented properties have a `;` in place of a `get_body` or `set_body`:
    ```cs
    access_modifier type Name { get; set; }
    ```
* To restrict the ability to read from or set a property, omit the `get` or `set` function.

### Access Modifiers
Access Modifiers — A keyword that controls which parts of code can access a type or its members.
* Access modifiers function differently depending on what they are assigned to. A type (such as a class or interface) can have an access modifier, and so can a type's members.

C# has seven access modifiers:
* There are three access modifiers common to several languages:
    * `public`: Member or type is accessible to code inside and outside of the object.
    * `private`: Member or type is accessible by code inside of the object.
    * `protected`: Member or type is accessible by code inside of the object, and any types derived from the containing type.
* C# has four unique access modifiers:
    * `internal`: Member or type is accessible to code inside of the current assembly.
    * `protected internal`: Member or type is accessible to types derived from the containing type in a seperate assembly AND anywhere in the current assembly.
        * Note that this is *less* restrictive than either `internal` or `protected`.
    * `private protected`: `protected`, except limited to the current assembly only.
    * `file`: (applies to types only) Type is accessible in the current `.cs` file only.

When access modifiers are not specified, an access modifier is applied by default:
* all *types* (not members): `internal`
* interface and enum members: `public`
* class, record, and struct members: `private`

## Inheritance
Inheritance — A feature allowing derived classes to "inherit" members of a base class.

Base class — The class that the derived class inherits from. Also called the "parent" class.

Derived class — The class that inherits from the base class. Also called the "child" class.

In C#, classes are restricted to single inheritance. However, classes may inherit any number of interfaces.

### Syntax
* Inherited classes are specifed by adding a colon after the derived class' name, followed by classes and interfaces to inherit from.
    ```cs
    access_modifier class DerivedClassName : BaseClassName {
        // class body
    }
    ```
* To inherit from a class and an interface, or multiple interfaces, seperate each class or interface name with a comma. 
* To call a base class' constructor, use a colon after the parameter list on the parent class' constructor and call `base()`:
    ```cs
    access_modifier class DerivedClassName : BaseClassName {
        access_modifier DerivedClassName(parameters) : base(base_parameters) {
            // constructor body
        }
    }
    ```

### Virtual Modifier
* The `virtual` modifier can be applied to properties and methods to allow a deriving class to implement its own version. If `virtual` properties or methods are not overridden, they will use the implementation defined in the base class.

Syntax:
```cs
abstract class Animal {
    public abstract string Sound { get; }

    // any classes that derive from this will inherit this version of 'speak()'
    // however, they can override it if they desire
    public virtual void speak() {
        System.Console.WriteLine(Sound);
    }
}
```

### Override Modifier
* The `override` modifier can be applied to properties and methods to indicate they override a base class property or method with the same name.
* Instead of calling the base class' method or using the base class' property, the overridden one is used instead.
* The property or method in the base class **must be marked `virtual` or `abstract` in order to be overridden**.

Syntax:
```cs
abstract class Animal {
    public abstract string Sound { get; }

    public virtual void speak() {
        System.Console.WriteLine(Sound);
    }
}

class Dog : Animal {
    // property
    public override string Sound { get => "Woof"; }

    // method
    public override void speak() {
        System.Console.out($"I am a dog, {Sound}!");
    }
}
```

To access a property or method that was overridden, add `base` in front of the property or method's name:
```cs
// within 'Dog'
base.speak(); // prints "Woof"
```

## Abstract Modifier
* The `abstract` modifier can be applied to classes, properties, and methods.
    * It is not applicable to types other than classes.

### Abstract Classes
* An abstract class is a class that provides a template to derive other classes from.
* Classes are marked as `abstract` when it does not make sense to be able to initialize the class, but the class is still useful as a base class to derive from.
    * For example, consider an 'Animal' base class inherited by 'Dog' and 'Cat' classes: It does not make sense to have an Animal, so the class shouldn't be able to be constructed, but there are several characteristics shared by cats and dogs that could be placed into the Animal class to avoid duplicating code.
* To mark a class as abstract, place the `abstract` modifier before the `class` keyword:
```cs
access_modifier abstract class ClassName {
    // class body
}
```

### Abstract Methods & Properties
* The `abstract` modifier can be applied to properties and methods in the same way as the `virtual` modifier, however, the `abstract` modifier *requires* the deriving class to override the property or method.
* The `abstract` modifier can only be applied to properties and methods within abstract classes.
* The definition of a property or method is omitted when marked `abstract`.

Syntax:
```cs
abstract class Animal {
    // the 'Sound' property is not defined here
    public abstract string Sound { get; }

    // not all properties or methods in an abstract class must be abstract
    // this one will be inherited by derived classes and works just fine
    public virtual void speak() {
        System.Console.WriteLine(Sound);
    }
}

class Dog : Animal {
    // the 'Sound' property must be defined in derived classes
    public override string Sound { get => "Woof"; }
}
```

## Interfaces
* An interface is a special type that can only be inherited. It is similar to an abstract class with exclusively abstract properties and methods.
    * This means that properties and methods are not defined in the interface.
    * As of C# 8.0, interfaces can provide default implementations of properties and methods (meaning that interfaces behave like an abstract class with **abstract or virtual** properties and methods).
* Interfaces are used to add common functionality to a type without violating C#'s single inheritance rule, since a type can inherit any amount of interfaces.
* The inheriting type must implement all properties and methods defined within the interface. It is not necessary to use the `override` modifier when implementing properties and methods from an interface.

Syntax:
```cs
// 'interface' is used to define an interface
interface ISellable {
    // declarations for properties
    public decimal UnitPrice { get; set; }
    public string Description { get; }
    public string ?SKU { get; set; }
}

abstract class DomesticatedAnimal : ISellable {
    public string Name { get; protected set; }

    // derived class must define properties;
    // notice lack of 'override' modifier
    public string Description { get {return Name;} }
    public decimal UnitPrice { get; set; }
    public string ?SKU { get; set; }
}
```